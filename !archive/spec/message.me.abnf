message           = simple-message / complex-message

simple-message    = [simple-start pattern]
pattern           = *(text-char / text-escape / placeholder)
placeholder       = expression / markup

complex-message   = *(declaration [s]) complex-body
declaration       = input-declaration / local-declaration / reserved-statement
complex-body      = quoted-pattern / matcher

input-declaration = input [s] variable-expression
local-declaration = local s variable [s] "=" [s] expression

quoted-pattern    = "{{" pattern "}}"

matcher           = match-statement 1*([s] variant)
match-statement   = match 1*([s] selector)
selector          = expression
variant           = key *(s key) [s] quoted-pattern
key               = literal / "*"

; Expressions
expression            = literal-expression
                      / variable-expression
                      / annotation-expression
literal-expression    = "{" [s] literal [s annotation] *(s attribute) [s] "}"
variable-expression   = "{" [s] variable [s annotation] *(s attribute) [s] "}"
annotation-expression = "{" [s] annotation *(s attribute) [s] "}"

annotation            = function
                      / private-use-annotation
                      / reserved-annotation

; Markup; Note that standalone markup is part of the first line
markup       = "{" [s] markup-open *(s attribute) [s] ["/"] "}"
             / "{" [s] markup-close *(s attribute) [s] "}"
markup-open  = "#" identifier *(s option)
markup-close = "/" identifier

; Expression and literal parts
function       = ":" identifier *(s option)
option         = identifier [s] "=" [s] (literal / variable)
; Attributes are reserved for future standardization
attribute      = "@" identifier [[s] "=" [s] (literal / variable)]

variable       = "$" name
literal        = quoted / unquoted
quoted         = "|" *(quoted-char / quoted-escape) "|"
unquoted       = name / number-literal
; number-literal matches JSON number (https://www.rfc-editor.org/rfc/rfc8259#section-6)
number-literal = ["-"] (%x30 / (%x31-39 *DIGIT)) ["." 1*DIGIT] [%i"e" ["-" / "+"] 1*DIGIT]

; Keywords; Note that these are case-sensitive
input = %s".input"
local = %s".local"
match = %s".match"

; Reserve additional .keywords for use by future versions of this specification.
reserved-statement = reserved-keyword [s reserved-body] 1*([s] expression)
; Note that the following production is a simplification,
; as this rule MUST NOT be considered to match existing keywords
; (`.input`, `.local`, and `.match`).
reserved-keyword   = "." name

; Reserve additional sigils for use by future versions of this specification.
reserved-annotation       = reserved-annotation-start reserved-body
reserved-annotation-start = "!" / "%" / "*" / "+" / "<" / ">" / "?" / "~"

; Reserve sigils for private-use by implementations.
private-use-annotation    = private-start reserved-body
reserved-body             = *([s] 1*(reserved-char / reserved-escape / quoted))

; Names and identifiers
; identifier matches https://www.w3.org/TR/REC-xml-names/#NT-QName
; name matches https://www.w3.org/TR/REC-xml-names/#NT-NCName
identifier = [namespace ":"] name
namespace  = name
name       = name-start *name-char

; Restrictions on characters in various contexts

text-char         = content-char / s / "." / "@" / "|"
quoted-char       = content-char / s / "." / "@" / "{" / "}"
reserved-char     = content-char / "."

; Character escapes
quoted-escape   = backslash ( backslash / "|" )
reserved-escape = backslash ( backslash / "{" / "|" / "}" )
