options {
    // OUTPUT_DIRECTORY = "./src/main/java/com/brentcroft/pxr/parser/out";
    // LOOKAHEAD = 6; // (default 1)
    UNICODE_INPUT = true;
    STATIC = false;

////    CHOICE_AMBIGUITY_CHECK = 2;
////    OTHER_AMBIGUITY_CHECK = 1;

////    DEBUG_PARSER = false;
////    DEBUG_LOOKAHEAD = false;
////    DEBUG_TOKEN_MANAGER = false;
////    ERROR_REPORTING = true;
////    IGNORE_CASE = false;
////    USER_TOKEN_MANAGER = false;
////    USER_CHAR_STREAM = false;
////    BUILD_PARSER = true;
////    BUILD_TOKEN_MANAGER = true;
////    SANITY_CHECK = true;
////    FORCE_LA_CHECK = true;
////    GENERATE_GENERICS = true;
    // GENERATE_STRING_BUILDER = true;
////    KEEP_LINE_COLUMN = false;
    JAVA_TEMPLATE_TYPE = "modern";
    JDK_VERSION = "1.8";
}

PARSER_BEGIN( MF2Parser )

package com.mihnita.tests.mf2_parse_javacc.grammar;

import java.io.BufferedReader;
import java.io.Reader;
import java.io.StringReader;

import java.util.Arrays;

public class MF2Parser {
  StringBuilder text = new StringBuilder();

  public static void message(String input) throws ParseException {
	Reader reader = new BufferedReader(new StringReader(input));
    MF2Parser parser = new MF2Parser(reader);
    parser.pattern();
  }

  public static MF2Parser parsed(String input) throws ParseException {
	Reader reader = new BufferedReader(new StringReader(input));
    return new MF2Parser(reader);
  }

}

PARSER_END( MF2Parser )

<DEFAULT> SKIP: { " " | "\t" | "\n" | "\r" }

TOKEN :
{
  <LCURLY: "{"> : IN_MESSAGE
}

//TOKEN : {
//  < TEXT_CHAR : [
//    "\u0000"-"\u005B", // omit \
//    "\u005D"-"\u007A", // omit {
//    "\u007C",          // omit }
//    "\u007E"-"\uD7FF", // omit surrogates
//    "\uE000"-"\uFFFF" 
//  ] >
//}

<IN_MESSAGE> TOKEN :
{
  <#STRING_DOUBLE_BODY :
    (
      (~[ "{", "}", "\\" ])
    |
      ( "\\" ( "\\" | "{" | "}" ) )
    )+>
| <STRING_DOUBLE_NONEMPTY : <STRING_DOUBLE_BODY> "}"> : DEFAULT
}

//TOKEN: {
//<QUOTED:
//    "\"" 
//    (
//         "\\" ~[]     //any escaped character
//    |                 //or
//        ~["\"","\\"]  //any character except quote or backslash
//    )* 
//    "\"" > 
//}

// =============

void pattern() : {}
{
   "{" text() "}" < EOF >
}

void text() : {}
{
  ( <STRING_DOUBLE_NONEMPTY> )*
}

String variable () : { Token t; Token sigil; }
{
  sigil = "$" t = < NAME >
  { return sigil.image + t.image; }
}

TOKEN: {
  < #FUNC_SIGIL : [ ":", "+", "-" ] >
| < FUNCTION : < FUNC_SIGIL > < NAME > >
}

Token function() : { Token r; }
{
  r = < FUNCTION >
  { return r; }
}

Token name() : { Token t; }
{
  t = < NAME >
  { return t; }
}

TOKEN: {
< #NAME_START : [
	"a"-"z", "A"-"Z",
    "_",
    "\u00C0"-"\u00D6",
    "\u00D8"-"\u00F6",
    "\u00F8"-"\u02FF",
    "\u0370"-"\u037D", 
    "\u037F"-"\u1FFF",
    "\u200C"-"\u200D",
    "\u2070"-"\u218F",
    "\u2C00"-"\u2FEF", 
    "\u3001"-"\uD7FF",
    "\uF900"-"\uFDCF",
    "\uFDF0"-"\uFFFD"
    // "\u0010000-EFFFF"
   ]
>
| < #NAME_CHAR : < NAME_START > | [
        "0"-"9",
		"-", ".", "\u00B7",
		"\u0300"-"\u036F",
		"\u203F"-"\u2040"
  ]
>
| < NAME : < NAME_START > (< NAME_CHAR >)* >
}
